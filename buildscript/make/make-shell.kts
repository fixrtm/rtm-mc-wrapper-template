import java.io.File

class Main {

    var index = 0

    var isBash = false

    val rootBuilder = StringBuilder()
    val finalBuilder = StringBuilder()
    val mainBuilder = StringBuilder()
    var currentBuilder = rootBuilder

    fun main(inFile: String, outFile: String) {
        File(inFile).reader().useLines { lines ->
            for (line in lines) {
                if (line.isBlank()) continue

                val parts = line.trim().split(' ')

                index = 0

                val madeLine = parseLine(parts)

                check (parts.size == index) { "line: $line" }

                if (madeLine != null) {
                    currentBuilder.appendln(madeLine)
                }
            }
        }

        with(File(outFile).printWriter()) {
            if (isBash) {
                println("#!/bin/bash")
                println("")
            }
            println("#")
            println("# Do not edit this file!")
            println("# This file is generated by a generator contain in make directory.")
            println("# This file and the generator is published under Creative Commons Zero 1.0 License or later")
            println("# http://creativecommons.org/publicdomain/zero/1.0/deed")
            println("#")
            println(rootBuilder)
            println()
            println("function final {")
            if (isBash) {
                println(":")
            }
            println(finalBuilder)
            println("}")
            println()
            if (isBash) {
                println("trap final EXIT")
                println()
            } else {
                println("try {")
            }
            println(mainBuilder)
            if (isBash) {
                println()
            } else {
                println("} finally {")
                println("final")
                println("}")
                println()
            }
            close()
        }
        rootBuilder.setLength(0)
        finalBuilder.setLength(0)
        mainBuilder.setLength(0)
    }

    private fun parseLine(parts: List<String>): String? = when (parts[index++]) {
        "set" -> if (isBash) "${parts[index++]}=${parse(parts)}"
        else "$${parts[index++]}=${parse(parts)}"

        "final" -> nul { currentBuilder = finalBuilder }
        "end_final" -> nul { currentBuilder = rootBuilder }
        "main" -> nul { currentBuilder = mainBuilder }
        "end_main" -> nul { currentBuilder = rootBuilder }

        "load_config" -> {
            if (isBash) ". ${parse(parts)}"
            else "\$config = get-content ${parse(parts)} | ConvertFrom-StringData\n" +
                    "\$config_version = \$config.config_version\n" +
                    "\$config_included = \$config.config_included"
        }

        "function" -> {
            val name = parts[index++]
            val count = parts[index++].toInt()
            if (isBash) "function $name {"
            else "function $name (${(1..count).joinToString { "$$it" }}) {"
        }
        "end_function" -> "}"

        "if" -> {
            if (isBash) "if ${parse(parts)}; then"
            else "if (${parse(parts)}) {"
        }
        "else" -> {
            if (isBash) "else"
            else "} else {"
        }
        "end_if" -> {
            if (isBash) "fi"
            else "}"
        }

        else -> {
            index--
            parse(parts)
        }
    }

    private fun parse(parts: List<String>): String = when (parts[index++]) {
        "exec" -> if (isBash) "\"$(${parse(parts)})\""
        else parse(parts)

        "get" -> if (isBash) "\"$${parts[index++]}\""
        else "$${parts[index++]}"

        "make-temp" -> if (isBash) "mktemp"
        else "New-TemporaryFile"

        "rm" -> if (isBash) "rm -rf ${parse(parts)}"
        else "\$null = Remove-Item -Recurse -Force -ea 0 -Path ${parse(parts)}"

        "mkdir" -> if (isBash) "mkdir -p ${parse(parts)}"
        else "\$null = New-Item -ItemType Directory -ea 0 -Path ${parse(parts)}"

        "str" -> {
            val startIndex = index
            var lastIndex = index
            for (index in index..parts.lastIndex) {
                if (parts[index] == "str")
                    break
                lastIndex = index + 1
            }
            index = lastIndex
            parts.subList(startIndex, lastIndex).joinToString(" ", "\"", "\"")
        }

        "wget" -> if (isBash) "wget -q ${parse(parts)} -O ${parse(parts)}"
        else "Invoke-WebRequest -Uri ${parse(parts)} -OutFile ${parse(parts)}"

        "unzip" -> if (isBash) "unzip -qq ${parse(parts)} -d ${parse(parts)}"
        else "Expand-Archive -Path ${parse(parts)} -DestinationPath ${parse(parts)}"
        
        "mv" -> if (isBash) "mv ${parse(parts)} ${parse(parts)}"
        else "Move-Item ${parse(parts)} ${parse(parts)}"

        "cd" -> if (isBash) "cd ${parse(parts)}"
        else "Set-Location ${parse(parts)}"

        "zip" -> if (isBash) "zip -r ${parse(parts)} ./*"
        else "Compress-Archive -Path ./* -DestinationPath  ${parse(parts)}"

        "call" -> buildString {
            val count = parts[index++].toInt()
            append(parts[index++])

            repeat(count) {
                append(' ')
                append(parse(parts))
            }
        }

        "exits" -> if (isBash) "[ -f ${parse(parts)} ]"
        else "[System.IO.File]::Exists(${parse(parts)})"

        "echo" -> if (isBash) "echo ${parse(parts)}"
        else "Write-Output ${parse(parts)}"

        "exit" -> "exit ${parts[index++]}"

        else -> error("invalid line: $parts")
    }

    private inline fun nul(block: () -> Unit): Nothing? {
        block()
        return null
    }
}

with(Main()) {
    if (args.size == 2) {
        // template and outdir
        val template = args[0]
        val templateName = File(template).name.removeSuffix(".template.txt")
        val outdir = args[1]

        isBash = false
        main(template, "$outdir/$templateName.ps1")
        isBash = true
        main(template, "$outdir/$templateName.sh")
    } else if (args.size == 3) {
        when (val arg = args[0]) {
            "bash" -> isBash = true
            "pwsh" -> isBash = false
            else -> error("invalid: $arg")
        }
        main(args[1], args[2])
    } else {
        error("size of arguments invalid")
    }
}
